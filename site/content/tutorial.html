<h1>Tutorial</h1>

<p>This page contains a tutorial introduction to the Tetra programming
Language.  Its intent is to be a quick and straightforward introduction to
Tetra for experienced programmers.</p>


<hr />
<h3>Hello World</h3>

<p>By law and custom, we will begin with the "Hello world" program which in
Tetra can be written as:</p>

<pre>
# hello world example
def main():
    print("Hello World!")
</pre>

<p>Comments in Tetra begin with the <tt>#</tt> character and continue to the
end of the line.  The first line of this program is a comment, and the rest is
the body of the program.</p>

<p>Every Tetra program must contain a function called <tt>main</tt> which
defines where the program begins executing.  Functions are defined with the
<tt>def</tt> keyword, then the name of the function, followed by the list of
parameters.  The main function takes no parameters.  The colon character is
used to mark the beginning of the function body which must be indented one
level over.</p>

<p>The <tt>print</tt> function is used for printing things, so we pass the
string "Hello World!" into it to print it to the screen.</p>



<hr />
<h3>Simple Types</h3>

<p>Tetra contains six simple types.  Each of these is indivisible, but can be
combined up in arrays, maps, classes etc. as discussed later on.  The simple
types are:</p>

<ul>
<li><p><b>int</b></p><p>
An integer type variable which can be positive or negative, but cannot contain
a fractional part.  These are signed 64-bit values.

</p></li>
<li><p><b>real</b></p><p>
A real (floating point) number variable which can contain a fractional part.
These are 64-bit values following the IEEE double-precision standard.

</p></li>
<li><p><b>bool</b></p><p>
A single boolean value which can store the values either <tt>true</tt> or
false.

</p></li>
<li><p><b>string</b></p><p>
A string is a piece of text.  Strings are stored as a sequence of Unicode
characters.


</p></li>
<li><p><b>task</b></p><p>
A task is an executing thread of execution.  We can wait for a task to complete
as described under the background execution section.


</p></li>
<li><p><b>lock</b></p><p>
A lock is used to coordinate between multiple parallel tasks.  We can use them
to prevent threads from interfering with each other as described in the section
on locks.



</p></li></ul>








<hr />
<h3>Functions</h3>

<p>As described above, functions are introduced with the <tt>def</tt> keyword,
and also have names and parameter lists.  Functions can also return values, and
there return type (if any) goes after the parameter list, but before the
colon.</p>

<p>Below is a function which computes the average of three parameters:</p>

<pre>
def average_of_three(v1 real, v2 real, v3 real) real:
    return (v1 + v2 + v3) / 3.0;
</pre>

<p>Note that types go <i>after</i> their variables and not before.  The
<tt>return</tt> statement is used to specify the return value of a function and
return control back to the caller.</p>

<p>Functions are called similarly to how they are in most programming
languages, with the values of parameters passed in at the call.  The
<tt>average_of_three</tt> function above might be called as follows in
main:</p>

<pre>
def main():
    avg = average_of_three(4.5, 7.2, 6.3)
    print(avg)
</pre>




<hr />
<h3>Variables</h3>

<p>If you look at the example call to <tt>average_of_three</tt> above, you will
notice that there is no declaration of the type of the <tt>avg</tt> variable.
Local variables (those which exist only inside of a function) do not need type
declarations in Tetra, the compiler will figure out the type of each based on
how the variable is used.  Only function parameters and return types need to be
given values.</p>

<p>Global variables can also be created, by using the <tt>global</tt> keyword,
as shown in the following example:</p>

<pre>
global count = 0

def increment():
    count += 1

def main( ):
    increment()
    increment()
    increment()
    print(count)
</pre>

<p>Of course global variables should be avoided in general!</p>

<p>Tetra also allows constant variables to be created with the
<tt>constant</tt> keyword:</p>

<pre>
constant PI = 3.141592653589
</pre>

<p>Notice that globals and constants also do not need type declarations.</p>




<hr />
<h3>Operators</h3>

<p>Tetra supports many common operators.  The following chart shows the
operators that Tetra supports organized by precedence levels, from highest
precedence to lowest, along with the associativity:</p>

<table cellpadding="5" border="1">
<tr><td><b>Operator</b></td><td><b>Meaning</b></td><td><b>Associativity</b></td></tr>
<tr><td>**</td><td>Exponentiation</td><td>Right</td></tr>
<tr><td>+ - ~</td><td>Unary plus, unary minus, and unary bitwise not</td><td>Unary</td></tr>
<tr><td>% / *</td><td>Modulus, division, multiplication</td><td>Left</td></tr>
<tr><td>+ -</td><td>Addition and subtraction</td><td>Left</td></tr>
<tr><td>&lt;&lt; &gt;&gt;</td><td>Bitwise left shift and right shift</td><td>Left</td></tr>
<tr><td>&amp;</td><td>Bitwise and</td><td>Left</td></tr>
<tr><td>^</td><td>Bitwise xor</td><td>Left</td></tr>
<tr><td>&#124;</td><td>Bitwise or</td><td>Left</td></tr>
<tr><td>&lt; &lt;= &gt; &gt;= == !=</td><td>Comparison operators</td><td>Left</td></tr>
<tr><td>and</td><td>Logical and</td><td>Left</td></tr>
<tr><td>or</td><td>Logical or</td><td>Left</td></tr>
<tr><td>=</td><td>Assignment (including +=, -= etc)</td><td>Right</td></tr>
</table>











<hr />
<h3>Selection Statements</h3>

<p>Tetra provides the if, elif, else statements, which work similarly to other
programming languages.  Below is a program which prints out whether a number is
positive, negative, or zero:</p>

<pre>
def print_sign(val int):
    if val &lt; 0:
        print(val, " is negative")
    elif val &gt; 0:
        print(val, " is positive")
    else:
        print(val, " is zero")

def main( ):
    print("Enter a value: ")
    val = read_int()
    print_sign(val)
</pre>

<P>Notice that the keyword is <tt>elif</tt> all as one word, and not "else if".
Also, notice that print can take multiple parameters, and that the
<tt>read_int</tt> function can be used to read an int from the user.</p>



<hr />
<h3>While Loops</h3>

<p>While loops are blocks of code that continue to execute while some condition
is true.  For example, the following function returns the factorial of a number
using a while loop:</p>

<pre>
def fact(x int) int:
    result = 1
    while x &gt; 0:
        result *= x
        x -= 1
    return result
</pre>

<p>The while loop starts by evaluating its condition and, if true, executes the
body of the loop.  It continues to do this until the condition is false at
which point it will continue to the code after the loop.</p>





<hr />
<h3>Parallel Execution</h3>

<p>Normally, Tetra functions are executed sequentially line by line, following
the control flow as dictated by function calls and returns, loops, and
selection statements.  However, we can also specify that statements should be
executed in parallel.</p>

<p>This is done using the <tt>parallel</tt> keyword, followed by a number of
statements in the parallel block.  For example, this program calls the print
function two times in parallel, and then calls it a third time:</p>

<pre>
def main():
    parallel:
        print("Print statement number 1!\n")
        print("Print statement number 2!\n")
    print("Print statement number 3!\n")
</pre>

<p>When this program is run, the two print statements will be executed at the
same time.  This program may print the first two messages in any order.
Sometimes the first message appears first, and other times the second one will
appear first.  It is even possible that they will appear inter-leaved, with the
beginning of one message, followed by the beginning of the other, followed by
the ends of each of them</p>

<p>Because the third print call is <i>outside</i> of the parallel block, it
will not start executing until the other two have both completed.</p>

<p>Of course normally we would only execute different pieces of code in
parallel if they can be executed together in any order without changing the
behavior of the program.  For example, we might call multiple functions in
parallel to compute values which are independent of each other:</p>

<pre>
def main():
    parallel:
        result1 = process(data_set1)
        result2 = process(data_set2)
        result3 = process(data_set3)
    display_results(result1, result2, result3)
</pre>

<p>Here, the three calls to a function called "process" will proceed in
parallel independently of each other.  When all three have returned, the
program will move past the parallel block to call the "display_results"
function.</p>

<p>Note that the parallel works with <i>statements</i>.  Often the statements
will be function calls, but they do not have to be.  We could run two while
loops in parallel for instance:</p>

<pre>
def main():
    i = 1
    j = 1
    sum = 0
    product = 1
    parallel:
        while i &lt; 10:
            sum += i
            i += 1
        while j &lt; 10:
            product *= j
            j += 1
</pre>

<p>Here, the two while loops are executed in two parallel threads.  Each while
loop itself is implemented sequentially, so this program will compute the sum
and product of the numbers 1-10 in two parallel loops.</p>



<hr />
<h3>Arrays</h3>

<p>Arrays package together multiple variables of the same type, such that they
can be accessed by an integer index.  Arrays are indexed by placing the index
between square brackets after the name of the array.  The following example
program counts the number of times a string appears in an array of strings:</p>

<pre>
def main( ):
    numbers = [10, 20, 30]
    total = numbers[0] + numbers[1] + numbers[2]
    print(total)
</pre>

<p>Data type declarations, such as with function parameters, with arrays are
done by placing the type of each element in brackets.  For example, the
following function takes an array of numbers and returns whether or not the
length of it is even:</p>

<pre>
def even_length(values [int]) bool:
    if len(values) % 2 == 0:
        return true
    else:
        return false
</pre>

<p>Multi-dimensional arrays can also be created.  In this case, you would
simply increase the number of brackets in the type.  For example, a 2D array of
reals would be declared as having type <tt>[[real]]</tt>.</p>


<hr />
<h3>For Loops</h3>

<p>Arrays lead us naturally to the Tetra <tt>for</tt> loop which loop over each
item in an array.  For example, the following function loops over the array it
is given and prints each element:</p>

<pre>
def print_all(values [int]):
    for value in values:
        print(value, "\n")
</pre>

<p>This for loop assigns each element in the array that it is given to the loop
variable one by one, then executes the loop body for that particular value.</p>



<hr />
<h3>Parallel For Loops</h3>

<p>We can also use the parallel for loop which is similar to the for loop as
described above, except that it is preceded with the <tt>parallel</tt> keyword,
and each of its loop iterations can be executed in parallel.</p>

<p>If we make the for loop above into a parallel for loop, then the calls to
print can be executed all at the same time and so can appear inter-leaved and
in any order.  Calling the function with the values 1 through 100, as in this
program:</p>

<pre>
def print_all(values [int]):
    parallel for value in values:
        print(value, "\n")

def main():
    print_all([1 ... 100])
</pre>

<p>Produces different results at each run.  The beginning of one run is shown
below:</p>

<pre>
13
4
2
6

7
8
10
11
12
91314

15
16
</pre>

<p>Notice that the results are not only out of order, but in this case
inter-leaved since sometimes multiple numbers get printed back to back, and
sometimes multiple new lines are printed back to back.</p>

<p>We would only want to use parallel for loops when the order of the loop
iterations is not important for the program to be correct.  As an example,
suppose we are writing a function which takes an array of numbers and returns
an array of those numbers squared.  Here, each of the elements can be computed
independently, and so could be done with a parallel for loop:</p>

<pre>
def square_all(values [real]):
    squares [real] = array(len(values))
    i = 0
    parallel for val in values:
        squares[i] = val * val
        i += 1
    return squares
</pre>

<p>The <tt>array</tt> function creates an array of a given size.</p>





<hr />
<h3>Background Execution</h3>

<p>The <tt>parallel</tt> keyword can be used to launch multiple statements at
the same time, which allows the original thread to launch multiple tasks at
once, and pause until they are done.</p>

<p>Something else we might want to do is have a thread launch one task which
begins executing, but the returns control back to the original thread
immediately.  For instance, we may want to launch a long-running task, but not
wait for it to finish immediately so we can move on to other things, such as
handling user input.</p>

<p>This can be done with Tetra using the <tt>background</tt> statement.  The
following program shows how this may be done to write a simple server type of
program:</p>

<pre>
def main():
    while true:
        request = wait_for_request()
        background:
            print("Handling a request!")
            handle_request(request)
</pre>

<p>This program uses a background block to handle each request it receives in a
separate thread of execution.  After the wait_for_request function returns, the
program will launch a thread to handle the background block's body, and then
immediately call wait_for_request again.</p>

<p>Note that the two statements inside the background block are executed
serially: first the print will execute and then the handle_request function
will be called.</p>


<hr />
<h3>Waiting</h3>

<p>Sometimes we may want to launch a thread in the background, but then wait
for it to finish executing at some later point in time.  For instance, suppose
we are writing a program which needs to download some data for use, but that it
can start the download before it really needs the data.  We can use a
background block with <tt>wait</tt> statement to implement this:</p>

<pre>
def main():
    background download_task:
        data = download_data()

    # do other things that don't need the data
    # ...
    
    wait download_task

    # now we use the data we got
</pre>

<p>Here we have given the background block a name, "download_task".  After
launching the task in the background, we can carry on doing things which don't
require the data.  Once we <i>do</i> need the data, we wait for it with the
<tt>wait</tt> statement which takes the task we wish to wait for.</p>

<p>If the task has finished already, the wait statement takes no time at all.
If it hasn't finished, it will not complete until the task we're waiting for
has completed.</p>

<p>The named background statement creates a variable of type <tt>task</tt>
which is first class data type in Tetra.  This means we can return tasks from
functions, put them in data structures etc.</p>





<hr />
<h3>Locks</h3>

<p>Sometimes when we have parallel code, we will need to prevent the threads
from interfering with each other.  For instance, if we are trying to find the
largest value in an array, we may keep track of the largest value we have seen
so far:</p>

<pre>
# find the max of an array
def max(nums [int]) int:
    largest = 0
    parallel for num in nums:
        if num &gt; largest:
            largest = num
    return largest
</pre>

<p>However, this program may produce the wrong answer because two threads may
execute the if condition at the same time, and both may find they have a value
which is larger than then current largest.  We would then have a situation
where only one of the threads actually writes its value, meaning one will be
lost, which may in fact have been the maximum.</p>

<p>To get around this, we put a lock statement around the code which updates
the largest:</p>

<pre>
# find the max of an array
def max(nums [int]) int:
    largest = 0
    parallel for num in nums:
        if num &gt; largest:
            lock:
                if num &gt; largest:
                    largest = num
    return largest
</pre>

<p>The lock statement creates a block of code which only one thread can enter
at a time.  Now, all of the threads can check if their value is larger than the
current largest, in parallel.  Once one finds that its value is in fact larger,
it tries to enter the block of code under the lock.  If another thread is
already in the block, the thread waits until it has finished before entering.
The thread then checks if its value is <i>still</i> larger than the current
largest (because it's possible a thread which just left the lock has modified
it since the last check) and then overwrites the largest variable.</p>

<p>The lock statement allows creating sections of our program which only one
thread can enter at a time which is often necessary when writing parallel
code.</P>



<hr />
<h3>Named Locks</h3>

<p>Sometimes it is necessary to have multiple sections of code which are locked
together.  For instance if we have a variable or resource that is being
accessed at multiple points in the program, we would want to have those locks
linked together, such that no more than one thread can be in <i>any</i> of
those sections at a time.</p>

<p>For instance the following program uses a global lock variable to prevent
two functions from over-writing the "negatives" value at the same time:</p>

<pre>
def main():
    negatives = 0

    parallel:
        for i in data1:
            if i &lt; 0:
                lock neg_lock:
                    negatives += 1
        for i in data2:
            if i &lt; 0:
                lock neg_lock:
                    negatives += 1
    print("There were ", negatives, " negative values.")
</pre>

<p>In this example, we are checking two sets of values for negative numbers in
parallel.  We have to protect the negatives variable, but it is accessed in two
distinct places in the code.  The fact that the locks are both named "neg_lock"
ensures that they are linked together.  Only one thread can be in <i>either</i>
block at the same time.</p>

<p>The named lock statement actually creates a variable of the <tt>lock</tt>
type. FUCK same keyword



<p>For instance, if we want to ensure that our output is never inter-leaved, we
will need to prevent multiple calls to print at the same time.  We can't do this
with the simple lock as shown above because that creates an independent locked
section.  Instead we can create named locks which are linked together by their
name.</p>



<hr />
<h3>Tuples</h3>







<hr />
<h3>Maps</h3>







<hr />
<h3>Classes</h3>






<hr />
<h3>Modules</h3>






<hr />
<h3>Function Types</h3>







<hr />
<h3>Lambda Functions</h3>

















