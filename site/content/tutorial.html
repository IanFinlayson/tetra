<h1>Tutorial</h1>

<p>This page contains a tutorial introduction to the Tetra programming
Language.  Its intent is to be a quick and straightforward introduction to
Tetra for experienced programmers.</p>


<hr />
<h3>Hello World</h3>

<p>By law and custom, we will begin with the "Hello world" program
which in Tetra can be written as:</p>

<pre>
# hello world example
def main():
    print("Hello World!")
</pre>

<p>Comments in Tetra begin with the <tt>#</tt> character and continue to the
end of the line.  The first line of this program is a comment, and the rest is
the body of the program.</p>

<p>Every Tetra program must contain a function called <tt>main</tt> which
defines where the program begins executing.  Functions are defined with the
<tt>def</tt> keyword, then the name of the function, followed by the list of
parameters.  The main function takes no parameters.  The colon character is
used to mark the beginning of the function body which must be indented one
level over.</p>

<p>The <tt>print</tt> function is used for printing things, so we pass the
string "Hello World!" into it to print it to the screen.</p>



<hr />
<h3>Simple Types</h3>

<p>Tetra contains four simple types.  Each of these is indivisible, but
can be combined up in arrays, maps, classes etc. as discussed later on.
The simple types are:</p>

<ul>
<li><p><b>int</b></p><p>
An integer type variable which can be positive or negative, but cannot contain
a fractional part.  These are signed 64-bit values.

</p></li>
<li><p><b>real</b></p><p>
A real (floating point) number variable which can contain a fractional part.
These are 64-bit values following the IEEE double-precision standard.

</p></li>
<li><p><b>bool</b></p><p>
A single boolean value which can store the values either <tt>true</tt> or
false.

</p></li>
<li><p><b>string</b></p><p>
A string is a piece of text.  Strings are stored as a sequence of Unicode
characters.

</p></li></ul>








<hr />
<h3>Functions</h3>

<p>As described above, functions are introduced with the <tt>def</tt> keyword,
and also have names and parameter lists.  Functions can also return values, and
there return type (if any) goes after the parameter list, but before the
colon.</p>

<p>Below is a function which computes the average of three parameters:</p>

<pre>
def average_of_three(v1 real, v2 real, v3 real) real:
    return (v1 + v2 + v3) / 3.0;
</pre>

<p>Note that types go <i>after</i> their variables and not before.  The
<tt>return</tt> statement is used to specify the return value of a function
and return control back to the caller.</p>

<p>Functions are called similarly to how they are in most programming
languages, with the values of parameters passed in at the call.  The
<tt>average_of_three</tt> function above might be called as follows in
main:</p>

<pre>
def main():
    avg = average_of_three(4.5, 7.2, 6.3)
    print(avg)
</pre>




<hr />
<h3>Variables</h3>

<p>If you look at the example call to <tt>average_of_three</tt> above, you will
notice that there is no declaration of the type of the <tt>avg</tt> variable.
Local variables (those which exist only inside of a function) do not need type
declarations in Tetra, the compiler will figure out the type of each based on
how the variable is used.  Only function parameters and return types need to be
given values.</p>

<p>Global variables can also be created, by using the <tt>global</tt> keyword,
as shown in the following example:</p>

<pre>
global count = 0

def increment():
    count += 1

def main( ):
    increment()
    increment()
    increment()
    print(count)
</pre>

<p>Of course global variables should be avoided in general!</p>

<p>Tetra also allows constant variables to be created with the <tt>constant</tt>
keyword:</p>

<pre>
constant PI = 3.141592653589
</pre>

<p>Notice that globals and constants also do not need type declarations.</p>




<hr />
<h3>Operators</h3>

<p>Tetra supports many common operators.  The following chart shows the
operators that Tetra supports organized by precedence levels, from highest
precedence to lowest, along with the associativity:</p>

<table cellpadding="5" border="1">
<tr><td><b>Operator</b></td><td><b>Meaning</b></td><td><b>Associativity</b></td></tr>
<tr><td>**</td><td>Exponentiation</td><td>Right</td></tr>
<tr><td>+ - ~</td><td>Unary plus, unary minus, and unary bitwise not</td><td>Unary</td></tr>
<tr><td>% / *</td><td>Modulus, division, multiplication</td><td>Left</td></tr>
<tr><td>+ -</td><td>Addition and subtraction</td><td>Left</td></tr>
<tr><td>&lt;&lt; &gt;&gt;</td><td>Bitwise left shift and right shift</td><td>Left</td></tr>
<tr><td>&amp;</td><td>Bitwise and</td><td>Left</td></tr>
<tr><td>^</td><td>Bitwise xor</td><td>Left</td></tr>
<tr><td>&#124;</td><td>Bitwise or</td><td>Left</td></tr>
<tr><td>&lt; &lt;= &gt; &gt;= == !=</td><td>Comparison operators</td><td>Left</td></tr>
<tr><td>and</td><td>Logical and</td><td>Left</td></tr>
<tr><td>or</td><td>Logical or</td><td>Left</td></tr>
<tr><td>=</td><td>Assignment (including +=, -= etc)</td><td>Right</td></tr>
</table>











<hr />
<h3>Selection Statements</h3>

<p>Tetra provides the if, elif, else statements, which work similarly to other
programming languages.  Below is a program which prints out whether a number is
positive, negative, or zero:</p>

<pre>
def print_sign(val int):
    if val &lt; 0:
        print(val, " is negative")
    elif val &gt; 0:
        print(val, " is positive")
    else:
        print(val, " is zero")

def main( ):
    print("Enter a value: ")
    val = read_int()
    print_sign(val)
</pre>

<P>Notice that the keyword is <tt>elif</tt> all as one word, and not "else if".
Also, notice that print can take multiple parameters, and that the
<tt>read_int</tt> function can be used to read an int from the user.</p>



<hr />
<h3>While Loops</h3>

<p>While loops are blocks of code that continue to execute while some condition
is true.  For example, the following function returns the factorial of a number
using a while loop:</p>

<pre>
def fact(x int) int:
    result = 1
    while x &gt; 0:
        result *= x
        x -= 1
    return result
</pre>

<p>The while loop starts by evaluating its condition and, if true, executes the
body of the loop.  It continues to do this until the condition is false at which
point it will continue to the code after the loop.</p>





<hr />
<h3>Parallel Execution</h3>

<p>Normally, Tetra functions are executed sequentially line by line, following
the control flow as dictated by function calls and returns, loops, and selection
statements.  However, we can also specify that statements should be executed
in parallel.</p>

<p>This is done using the <tt>parallel</tt> keyword, followed by a number of
statements in the parallel block.  For example, this program calls the print
function two times in parallel, and then calls it a third time:</p>

<pre>
def main():
    parallel:
        print("Print statement number 1!\n")
        print("Print statement number 2!\n")
    print("Print statement number 3!\n")
</pre>

<p>When this program is run, the two print statements will be executed at the
same time.  This program may print the first two messages in any order.
Sometimes the first message appears first, and other times the second one will
appear first.  It is even possible that they will appear inter-leaved, with the
beginning of one message, followed by the beginning of the other, followed by
the ends of each of them</p>

<p>Because the third print call is <i>outside</i> of the parallel block, it will
not start executing until the other two have both completed.</p>

<p>Of course normally we would only execute different pieces of code in parallel
if they can be executed together in any order without changing the behavior of
the program.  For example, we might call multiple functions in parallel to
compute values which are independent of each other:</p>

<pre>
def main():
    parallel:
        result1 = process(data_set1)
        result2 = process(data_set2)
        result3 = process(data_set3)
    display_results(result1, result2, result3)
</pre>

<p>Here, the three calls to a function called "process" will proceed in
parallel independently of each other.  When all three have returned, the
program will move past the parallel block to call the "display_results"
function.</p>




<hr />
<h3>Arrays</h3>

<p>Arrays package together multiple variables of the same type, such that they
can be accessed by an integer index.  Arrays are indexed by placing the index
between square brackets after the name of the array.  The following example
program counts the number of times a string appears in an array of strings:</p>

<pre>
def main( ):
    numbers = [10, 20, 30]
    total = numbers[0] + numbers[1] + numbers[2]
    print(total)
</pre>

<p>Data type declarations, such as with function parameters, with arrays are
done by placing the type of each element in brackets.  For example, the
following function takes an array of numbers and returns whether or not
the length of it is even:</p>

<pre>
def even_length(values [int]) bool:
    if len(values) % 2 == 0:
        return true
    else:
        return false
</pre>

<p>Multi-dimensional arrays can also be created.  In this case, you would simply
increase the number of brackets in the type.  For example, a 2D array of reals
would be declared as having type <tt>[[real]]</tt>.</p>


<hr />
<h3>For Loops</h3>

<p>Arrays lead us naturally to the Tetra <tt>for</tt> loop which loop over each
item in an array.  For example, the following function loops over the array it
is given and prints each element:</p>

<pre>
def print_all(values [int]):
    for value in values:
        print(value, "\n")
</pre>

<p>This for loop assigns each element in the array that it is given to the loop
variable one by one, then executes the loop body for that particular value.</p>



<hr />
<h3>Parallel For Loops</h3>

<p>We can also use the parallel for loop which is similar to the for loop as
described above, except that it is preceded with the <tt>parallel</tt> keyword,
and each of its loop iterations can be executed in parallel.</p>

<p>If we make the for loop above into a parallel for loop, then the calls to
print can be executed all at the same time and so can appear inter-leaved and
in any order.  Calling the function with the values 1 through 100, as in this
program:</p>

<pre>
def print_all(values [int]):
    parallel for value in values:
        print(value, "\n")

def main():
    print_all([1 ... 100])
</pre>

<p>Produces different results at each run.  The beginning of one run is shown
below:</p>

<pre>
13
4
2
6

7
8
10
11
12
91314

15
16
</pre>

<p>Notice that the results are not only out of order, but in this case
inter-leaved since sometimes multiple numbers get printed back to back, and
sometimes multiple new lines are printed back to back.</p>

<p>We would only want to use parallel for loops when the order of the loop
iterations is not important for the program to be correct.  As an example,
suppose we are writing a function which takes an array of numbers and returns
an array of those numbers squared.  Here, each of the elements can be computed
independently, and so could be done with a parallel for loop:</p>

<pre>
def square_all(values [real]):
    squares [real] = array(len(values))
    i = 0
    parallel for val in values:
        squares[i] = val * val
        i += 1
    return squares
</pre>







<hr />
<h3>Background Execution</h3>




<hr />
<h3>Waiting</h3>







<hr />
<h3>Locks</h3>





<hr />
<h3>Tuples</h3>







<hr />
<h3>Maps</h3>







<hr />
<h3>Classes</h3>






<hr />
<h3>Modules</h3>






<hr />
<h3>Function Types</h3>







<hr />
<h3>Lambda Functions</h3>

















